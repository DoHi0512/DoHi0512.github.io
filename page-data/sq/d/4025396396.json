{"data":{"allMarkdownRemark":{"nodes":[{"id":"89d0bf73-96c0-529d-b487-7dc9c1933d24","excerpt":"…","fields":{"slug":"/개발 외주/"},"frontmatter":{"date":"August 10, 2023","title":"[백준] 1931 회의실 배정 (c++)","description":"백준 1931","tags":["알고리즘","백준"],"thumbnail":"./baekjoon.png"},"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/1931)\n\n## 접근법\n\n### 첫번째 생각\n\n- 문제를 그리디하게 접근해서 우선순위 큐를 이용해 회의가 끝나는 시간이 작은것 부터 회의를 시작하는 로직을 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi/post/b3f06611-fb30-4b51-a794-3a4f170ed6cc/image.png)\n\n## 코드\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n, a, b, time = 0, cnt = 0;\n\tpriority_queue <pair<int, int>> que; // endTime,startTime\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tque.push({ -b,-a });\n\t}\n\twhile (!que.empty()) {\n\t\tint startTime = -que.top().second;\n\t\tint endTime = -que.top().first;\n\t\tque.pop();\n\t\tif (time > startTime) continue;\n\t\ttime = endTime;\n\t\tcnt += 1;\n\t}\n\tcout << cnt;\n}\n```\n\n- 우선순위 큐에 `pair` 를 넣게 되면 `first` 를 우선적으로 비교하기 때문에 회의가 끝나는 시간이 작은것 부터 회의를 시작한다.\n\n- 우선순위 큐는 큰 값을 우선적으로 뽑기 때문에 -를 붙여서 작은 값부터 뽑도록 변경하였다.\n\n- `if (time > startTime) continue;` 문을 넣어서 시작시간이 현재 시간보다 작으면 회의를 시작하지 못하므로 `continue` 를 해주었다.\n\n## 후기\n\n그리디 문제를 오랜만에 풀어봤는데 그리디는 문제의 풀이를 생각하는것보다 문제가 그리디인지 판별하는게 더 어렵다는 생각이 들었다.\n"},{"id":"74ffe0f5-afe0-5e67-a8da-6e95849087a9","excerpt":"문제 문제 링크 h1 h2 h3 h4","fields":{"slug":"/면접 준비/"},"frontmatter":{"date":"May 03, 2023","title":"프론트엔드 면접 준비(Javascript)","description":"백준 18809번","tags":["알고리즘","백준"],"thumbnail":"https://velog.velcdn.com/images/surim014/post/4303ab10-4d48-4977-8d5d-2564f992d04d/image.png"},"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n# h1\n\n## h2\n\n### h3\n\n#### h4\n"},{"id":"cdc1092b-279d-5139-8282-bfd46edf7f03","excerpt":"문제 문제 링크 접근법 첫번째 생각 배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다. 초록색, 빨강색 배양액의 개수는 총 1…","fields":{"slug":"/백준18809/"},"frontmatter":{"date":"May 01, 2023","title":"[번역] 프런트엔드 풀 리퀘스트를 작성하기 전에 이 체크리스트를 사용하세요.","description":"백준 18809번","tags":["알고리즘","백준"],"thumbnail":"https://velog.velcdn.com/images/dnr6054/post/f39db314-d94a-4c3a-b282-0439288d45d1/image.png"},"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n## 접근법\n\n### 첫번째 생각\n\n배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다.\n\n- 초록색, 빨강색 배양액의 개수는 총 10개라서 백트래킹을 사용해도 문제가 없을것이라고 생각했다.\n\n- 백트래킹을 한 뒤 BFS를 사용하여 최대 피울수 있는 꽃의 개수를 구하면 문제의 답을 구할수 있겠다고 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi0512/post/36c4b317-0700-4a2f-af1b-53ba5133cc57/image.png)\n\n내가 생각한 풀이가 맞았다.\n\n## 코드\n\n> 배양액의 경우의 수를 구하는 백트래킹\n\n```cpp\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\n```\n\n간단한 백트래킹으로 구현했다.\n\n> 피울수 있는 꽃의 개수를 구하는 BFS\n\n```cpp\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\n```\n\n피울수 있는 꽃의 개수를 리턴하였다.\n\n> 전체 코드\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint arr[51][51], n, m, maxi = -1, temp[51][51], dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\nbool inRange(int y, int x) {\n   if (y == n || y < 0 || x == m || x < 0) return false;\n   return true;\n}\nclass location {\npublic:\n   int x, y, col, dis;\n   location(int y, int x, int col, int dis) : y(y), x(x), col(col), dis(dis) {};\n};\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\nint main() {\n   int r, g;\n   cin >> n >> m >> g >> r;\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         cin >> arr[i][j];\n      }\n   }\n   queue <location> a;\n   bt(0, g, r);\n   cout << maxi;\n}\n```\n\n## 후기\n\n- 처음 생각한 로직이 맞아서 쉽게 풀 수 있는 문제였다.\n- **예전에 작성한 코드**라서 코드가 깔끔하지 못한점 이해 부탁드립니다.\n"}]}}}