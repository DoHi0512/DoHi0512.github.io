{"data":{"allMarkdownRemark":{"nodes":[{"id":"89d0bf73-96c0-529d-b487-7dc9c1933d24","excerpt":"문제 문제 링크 접근법 첫번째 생각 면접장까지의 최단경로를 구하는 문제이므로 다익스트라를 사용하였다. 간선을 반대로 잇고 모든 면접장에서 다익스트라를 사용했다. 다익스트라가 최대 N*N번 실행되어서 시간초과 발생(N…","fields":{"slug":"/개발 외주/"},"frontmatter":{"date":"May 02, 2023","title":"개발 외주 하는법과 비용 산정방법 총정리","description":"백준 18809번","tags":["알고리즘","백준"],"thumbnail":"https://velog.velcdn.com/images/unhyif/post/0685e6bf-9513-43c0-a47b-d497d59a0f84/image.gif"},"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/17835)\n\n## 접근법\n\n### 첫번째 생각\n\n면접장까지의 최단경로를 구하는 문제이므로 다익스트라를 사용하였다.\n\n간선을 반대로 잇고 모든 면접장에서 다익스트라를 사용했다.\n\n- 다익스트라가 최대 N\\*N번 실행되어서 시간초과 발생(N = 100000)\n\n### 두번째 생각\n\n면접장의 번호를 큐에 한번에 넣고 다익스트라를 실행하였다.\n\n- 구해진 거리 중 최대값이 정답이 된다.\n- 다익스트라를 한번만 돌리기 때문에 시간초과는 나지 않았다.\n- 하지만 80%부근에서 틀렸다.\n\n### 세번째 생각\n\n로직은 맞으나 실수가 발생했다고 생각해서 문제를 찾기 시작했다.\n\n- 간선의 최대 가중치는 100,000 최대 노드의 개수는 100,000개 이므로 최대값은 10,000,000,000이 나올 수 있다는걸 알아냈다.\n- 최대값을 작게 설정한것이 문제라고 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi0512/post/c142118a-5cbf-4d94-82e3-a5be5b3e0d55/image.png)\n최대값 설정의 문제가 맞았고 수정 후 맞았습니다!를 받았다.\n\n## 코드\n\n```cpp\n#include <bits/stdc++.h>\n#define INF 10987654321\n#define MAX 1000001\n#define lli long long int\nusing namespace std;\nlli n, m, s, a, b, w, k, ans;\nvector<vector<pair<lli, lli>>> arr(MAX);\nlli dis[MAX];\nlli maxi = -INF;\npriority_queue<pair<lli, lli>> que;\nvoid dijkstra() {\n    while (!que.empty()) {\n        lli dist = -que.top().first;\n        lli node = que.top().second;\n        que.pop();\n        if (dist > dis[node]) continue;\n        for (auto x : arr[node]) {\n            lli nxt = x.first;\n            lli cost = x.second;\n            if (dis[nxt] > dis[node] + cost) {\n                dis[nxt] = dis[node] + cost;\n                que.push({ -dis[nxt],nxt });\n            }\n        }\n    }\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    fill(dis, dis + MAX, INF);\n    cin >> n >> m >> k;\n    for (int i = 0; i < m; i++) {\n        cin >> a >> b >> w;\n        arr[b].push_back({ a,w });\n    }\n    for (int i = 0; i < k; i++) {\n        cin >> s;\n        que.push({ 0,s });\n        dis[s] = 0;\n    }\n    dijkstra();\n    for (int i = 1; i <= n; i++) {\n        if (maxi < dis[i]) {\n            ans = i;\n            maxi = dis[i];\n        }\n    }\n    cout << ans << '\\n' << maxi;\n}\n```\n\n## 후기\n\n다음부터는 문제를 잘 보고 최대값을 설정하는 습관을 들이도록 노력해야겠다.\n"},{"id":"74ffe0f5-afe0-5e67-a8da-6e95849087a9","excerpt":"문제 문제 링크 h1 h2 h3 h4","fields":{"slug":"/면접 준비/"},"frontmatter":{"date":"May 03, 2023","title":"프론트엔드 면접 준비(Javascript)","description":"백준 18809번","tags":["알고리즘","백준"],"thumbnail":"https://velog.velcdn.com/images/surim014/post/4303ab10-4d48-4977-8d5d-2564f992d04d/image.png"},"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n# h1\n\n## h2\n\n### h3\n\n#### h4\n"},{"id":"cdc1092b-279d-5139-8282-bfd46edf7f03","excerpt":"문제 문제 링크 접근법 첫번째 생각 배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다. 초록색, 빨강색 배양액의 개수는 총 1…","fields":{"slug":"/백준18809/"},"frontmatter":{"date":"May 01, 2023","title":"[번역] 프런트엔드 풀 리퀘스트를 작성하기 전에 이 체크리스트를 사용하세요.","description":"백준 18809번","tags":["알고리즘","백준"],"thumbnail":"https://velog.velcdn.com/images/dnr6054/post/f39db314-d94a-4c3a-b282-0439288d45d1/image.png"},"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n## 접근법\n\n### 첫번째 생각\n\n배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다.\n\n- 초록색, 빨강색 배양액의 개수는 총 10개라서 백트래킹을 사용해도 문제가 없을것이라고 생각했다.\n\n- 백트래킹을 한 뒤 BFS를 사용하여 최대 피울수 있는 꽃의 개수를 구하면 문제의 답을 구할수 있겠다고 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi0512/post/36c4b317-0700-4a2f-af1b-53ba5133cc57/image.png)\n\n내가 생각한 풀이가 맞았다.\n\n## 코드\n\n> 배양액의 경우의 수를 구하는 백트래킹\n\n```cpp\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\n```\n\n간단한 백트래킹으로 구현했다.\n\n> 피울수 있는 꽃의 개수를 구하는 BFS\n\n```cpp\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\n```\n\n피울수 있는 꽃의 개수를 리턴하였다.\n\n> 전체 코드\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint arr[51][51], n, m, maxi = -1, temp[51][51], dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\nbool inRange(int y, int x) {\n   if (y == n || y < 0 || x == m || x < 0) return false;\n   return true;\n}\nclass location {\npublic:\n   int x, y, col, dis;\n   location(int y, int x, int col, int dis) : y(y), x(x), col(col), dis(dis) {};\n};\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\nint main() {\n   int r, g;\n   cin >> n >> m >> g >> r;\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         cin >> arr[i][j];\n      }\n   }\n   queue <location> a;\n   bt(0, g, r);\n   cout << maxi;\n}\n```\n\n## 후기\n\n- 처음 생각한 로직이 맞아서 쉽게 풀 수 있는 문제였다.\n- **예전에 작성한 코드**라서 코드가 깔끔하지 못한점 이해 부탁드립니다.\n"}]}}}