{"data":{"allMarkdownRemark":{"nodes":[{"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/1931)\n\n## 접근법\n\n### 첫번째 생각\n\n- 문제를 그리디하게 접근해서 우선순위 큐를 이용해 회의가 끝나는 시간이 작은것 부터 회의를 시작하는 로직을 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi/post/b3f06611-fb30-4b51-a794-3a4f170ed6cc/image.png)\n\n## 코드\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n, a, b, time = 0, cnt = 0;\n\tpriority_queue <pair<int, int>> que; // endTime,startTime\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tque.push({ -b,-a });\n\t}\n\twhile (!que.empty()) {\n\t\tint startTime = -que.top().second;\n\t\tint endTime = -que.top().first;\n\t\tque.pop();\n\t\tif (time > startTime) continue;\n\t\ttime = endTime;\n\t\tcnt += 1;\n\t}\n\tcout << cnt;\n}\n```\n\n- 우선순위 큐에 `pair` 를 넣게 되면 `first` 를 우선적으로 비교하기 때문에 회의가 끝나는 시간이 작은것 부터 회의를 시작한다.\n\n- 우선순위 큐는 큰 값을 우선적으로 뽑기 때문에 -를 붙여서 작은 값부터 뽑도록 변경하였다.\n\n- `if (time > startTime) continue;` 문을 넣어서 시작시간이 현재 시간보다 작으면 회의를 시작하지 못하므로 `continue` 를 해주었다.\n\n## 후기\n\n그리디 문제를 오랜만에 풀어봤는데 그리디는 문제의 풀이를 생각하는것보다 문제가 그리디인지 판별하는게 더 어렵다는 생각이 들었다.\n","id":"4db6b57c-7566-5048-a396-04b4f8a6b823","excerpt":"…","fields":{"slug":"/개발 외주 copy/"},"frontmatter":{"date":"2023.08.10","title":"[백준] 1931 회의실 배정 (c++)","description":"백준 1931","tags":["알고리즘","백준"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/6e28df6de5db50ade5eb277b4753fa3c/c4e1b/baekjoon.png","srcSet":"/static/6e28df6de5db50ade5eb277b4753fa3c/2151b/baekjoon.png 709w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/194b8/baekjoon.png 1417w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/c4e1b/baekjoon.png 2834w","sizes":"(min-width: 2834px) 2834px, 100vw"},"sources":[{"srcSet":"/static/6e28df6de5db50ade5eb277b4753fa3c/fc48f/baekjoon.webp 709w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/f78ef/baekjoon.webp 1417w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/fd652/baekjoon.webp 2834w","type":"image/webp","sizes":"(min-width: 2834px) 2834px, 100vw"}]},"width":2834,"height":1480}}}},"timeToRead":1},{"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/1931)\n\n## 접근법\n\n### 첫번째 생각\n\n- 문제를 그리디하게 접근해서 우선순위 큐를 이용해 회의가 끝나는 시간이 작은것 부터 회의를 시작하는 로직을 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi/post/b3f06611-fb30-4b51-a794-3a4f170ed6cc/image.png)\n\n## 코드\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint main() {\n\tint n, a, b, time = 0, cnt = 0;\n\tpriority_queue <pair<int, int>> que; // endTime,startTime\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tque.push({ -b,-a });\n\t}\n\twhile (!que.empty()) {\n\t\tint startTime = -que.top().second;\n\t\tint endTime = -que.top().first;\n\t\tque.pop();\n\t\tif (time > startTime) continue;\n\t\ttime = endTime;\n\t\tcnt += 1;\n\t}\n\tcout << cnt;\n}\n```\n\n- 우선순위 큐에 `pair` 를 넣게 되면 `first` 를 우선적으로 비교하기 때문에 회의가 끝나는 시간이 작은것 부터 회의를 시작한다.\n\n- 우선순위 큐는 큰 값을 우선적으로 뽑기 때문에 -를 붙여서 작은 값부터 뽑도록 변경하였다.\n\n- `if (time > startTime) continue;` 문을 넣어서 시작시간이 현재 시간보다 작으면 회의를 시작하지 못하므로 `continue` 를 해주었다.\n\n## 후기\n\n그리디 문제를 오랜만에 풀어봤는데 그리디는 문제의 풀이를 생각하는것보다 문제가 그리디인지 판별하는게 더 어렵다는 생각이 들었다.\n","id":"89d0bf73-96c0-529d-b487-7dc9c1933d24","excerpt":"…","fields":{"slug":"/개발 외주/"},"frontmatter":{"date":"2023.08.10","title":"[백준] 1931 회의실 배정 (c++)","description":"백준 1931","tags":["알고리즘","백준"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/6e28df6de5db50ade5eb277b4753fa3c/c4e1b/baekjoon.png","srcSet":"/static/6e28df6de5db50ade5eb277b4753fa3c/2151b/baekjoon.png 709w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/194b8/baekjoon.png 1417w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/c4e1b/baekjoon.png 2834w","sizes":"(min-width: 2834px) 2834px, 100vw"},"sources":[{"srcSet":"/static/6e28df6de5db50ade5eb277b4753fa3c/fc48f/baekjoon.webp 709w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/f78ef/baekjoon.webp 1417w,\n/static/6e28df6de5db50ade5eb277b4753fa3c/fd652/baekjoon.webp 2834w","type":"image/webp","sizes":"(min-width: 2834px) 2834px, 100vw"}]},"width":2834,"height":1480}}}},"timeToRead":1},{"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n# h1\n\n## h2\n\n### h3\n\n#### h4\n","id":"74ffe0f5-afe0-5e67-a8da-6e95849087a9","excerpt":"문제 문제 링크 h1 h2 h3 h4","fields":{"slug":"/면접 준비/"},"frontmatter":{"date":"2023.05.03","title":"프론트엔드 면접 준비(Javascript)","description":"백준 18809번","tags":["알고리즘","백준"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg","srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/c9087/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/a83f3/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 917w","sizes":"(min-width: 917px) 917px, 100vw"},"sources":[{"srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/2b505/%EC%B5%9C%EC%A0%81%ED%99%94.webp 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/564c1/%EC%B5%9C%EC%A0%81%ED%99%94.webp 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/f701a/%EC%B5%9C%EC%A0%81%ED%99%94.webp 917w","type":"image/webp","sizes":"(min-width: 917px) 917px, 100vw"}]},"width":917,"height":1200}}}},"timeToRead":1},{"rawMarkdownBody":"\n# 1. Log4j\n\n## Log4j란?\n\nJava/Kotlin/Scala/Groovy/Clojure 코딩 도중에 프로그램의 로그를 기록해주는 라이브러리다.\n\n## Log4j 보안 이슈\n\n![](https://velog.velcdn.com/images/dohi/post/a061bd74-fba4-4d1b-b017-be113bb78f19/image.png)\n`JNDI` 와 `LDAP` 를 이용한 공격이다.\n\n> JNDP : Java Naming and Directory Interface(디렉토리를 통해 데이터를 찾게 해주는 서비스)\n\n> LDAP : JNDI의 인터페이스중 하나\n\n`Log4j` 에서는 편리하게 사용하기 위해 `${prefix:name}` 형식으로 객체를 찾는 문법이 존재함\n\n위와 같은 문법이 로그가 기록될 때도 사용 가능 -> 해커가 User-Agent와 같은 헤더 또는 여러가지 방법을 통해 취약점 공격\n\n# 2. ChatGPT\n\n## ChatGPT란?\n\nChatGPT는 OpenAI가 개발한 인공지능 챗봇이다.\n\n## ChatGPT 보안 이슈\n\nchatGPT에 기밀이 입력되어 유출되는 사고 발생\n\n삼성에서도 설비정보 유출 2건과 회의 내용 유출 1건이 발생함\n\n# 3. 최신 보안 동향\n\n![](https://velog.velcdn.com/images/dohi/post/871579cc-3b72-48c6-b659-23813047b2f1/image.png)\n\n이스트시큐리티 (알약) 에서 발표한 2023 보안 동향 5가지\n\n## 내용 정리\n\n2023년에는 국가 배후 해킹 조직의 사이버 안보 위협 증가, 랜섬웨어 변종과 APT 공격의 진화, 디지털 신분증과 전자 문서 서비스로 인한 개인정보 탈취, 가상 자산을 노리는 다양한 사이버 공격, 그리고 제로데이와 엔데이 취약점을 악용한 공격의 증가가 예상됩니다.\n\n특히, 국가 간 갈등과 관련하여 국가 간 갈등이 심화됨에 따라 해킹 조직의 공격이 증가할 것으로 예측되며, 미사일 발사 및 방어 기술, 항공우주산업, 이동통신 등 다양한 분야에서 해킹 공격이 늘어날 것으로 전망되었습니다.\n\n랜섬웨어의 지속적인 유포와 APT 공격의 진화도 주목할 만한 부분으로 언급되었습니다. 디지털 신분증과 전자 문서 서비스 확대로 인한 공격, 가상 자산과 NFT 발생을 돕는 플랫폼의 증가로 인한 공격, 그리고 제로데이 취약점과 엔데이 취약점을 악용한 공격이 더욱 빈번해질 것으로 예상되며, 새로운 제로데이 취약점 발견 및 악용이 증가하고 있는 상황이라고 하였습니다.\n\n## 느낀점\n\n아무리 보안이 발전해도 새로운 취약점은 계속 발견되고 그에 맞춰 새로운 공격 기술이 나타나는걸 보고 정보보안은 끝이 없다는걸 느꼈다.\n\n새로운 취약점을 계속 발견하는 사람도 놀랍지만 그에 맞추어서 계속해서 보완하는 사람이 대단하다고 생각했다. 정보보안을 전공하는 사람들이 돈을 많이 받는 이유를 알 것 같았다.\n\n요즘 모바일 운전면허증, 모바일 신분증 등 다양한 정보가 디지털로 넘어가는 추세인데, 먼 미래에는 내 모든 정보를 디지털에서 보관할수도 있겠다는 생각을 했다. 동시에 보안 취약점 때문에 내 모든 정보가 유출될수도 있다고 생각하니 겁이 났다.\n\n## 3줄 요약\n\n- 국가 간 해킹이 증가할것으로 예상됨\n- 최근에 등장한 Zero-Day 공격 및 N-Day 공격이 증가함\n- 모바일 신분증 등 디지털 신분증을 노리는 공격이 증가할것으로 예상됨\n\n## 출처\n\nhttps://www.itworld.co.kr/news/268791#csidxe9630f0e82a0f7a84dc54b184d164c7\n","id":"49fc4753-86f4-5df5-8b4c-8e09ee172bc4","excerpt":"1. Log4j Log4j란? Java/Kotlin/Scala/Groovy/Clojure 코딩 도중에 프로그램의 로그를 기록해주는 라이브러리다. Log4j 보안 이슈 \n 와  를 이용한 공격이다. JNDP…","fields":{"slug":"/보안 최신 동향/"},"frontmatter":{"date":"2023.08.17","title":"보안 최신 동향","description":"정보보안 이슈와 최신 정보 동향","tags":["정보보안"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/6efa1c3d4032d8084670c8672af575d6/d7f1b/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg","srcSet":"/static/6efa1c3d4032d8084670c8672af575d6/40721/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg 162w,\n/static/6efa1c3d4032d8084670c8672af575d6/eec7d/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg 325w,\n/static/6efa1c3d4032d8084670c8672af575d6/d7f1b/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg 649w","sizes":"(min-width: 649px) 649px, 100vw"},"sources":[{"srcSet":"/static/6efa1c3d4032d8084670c8672af575d6/984e9/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.webp 162w,\n/static/6efa1c3d4032d8084670c8672af575d6/070cc/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.webp 325w,\n/static/6efa1c3d4032d8084670c8672af575d6/02de4/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.webp 649w","type":"image/webp","sizes":"(min-width: 649px) 649px, 100vw"}]},"width":649,"height":370}}}},"timeToRead":1},{"rawMarkdownBody":"\n# 1. Log4j\n\n## Log4j란?\n\nJava/Kotlin/Scala/Groovy/Clojure 코딩 도중에 프로그램의 로그를 기록해주는 라이브러리다.\n\n## Log4j 보안 이슈\n\n![](https://velog.velcdn.com/images/dohi/post/a061bd74-fba4-4d1b-b017-be113bb78f19/image.png)\n`JNDI` 와 `LDAP` 를 이용한 공격이다.\n\n> JNDP : Java Naming and Directory Interface(디렉토리를 통해 데이터를 찾게 해주는 서비스)\n\n> LDAP : JNDI의 인터페이스중 하나\n\n`Log4j` 에서는 편리하게 사용하기 위해 `${prefix:name}` 형식으로 객체를 찾는 문법이 존재함\n\n위와 같은 문법이 로그가 기록될 때도 사용 가능 -> 해커가 User-Agent와 같은 헤더 또는 여러가지 방법을 통해 취약점 공격\n\n# 2. ChatGPT\n\n## ChatGPT란?\n\nChatGPT는 OpenAI가 개발한 인공지능 챗봇이다.\n\n## ChatGPT 보안 이슈\n\nchatGPT에 기밀이 입력되어 유출되는 사고 발생\n\n삼성에서도 설비정보 유출 2건과 회의 내용 유출 1건이 발생함\n\n# 3. 최신 보안 동향\n\n![](https://velog.velcdn.com/images/dohi/post/871579cc-3b72-48c6-b659-23813047b2f1/image.png)\n\n이스트시큐리티 (알약) 에서 발표한 2023 보안 동향 5가지\n\n## 내용 정리\n\n2023년에는 국가 배후 해킹 조직의 사이버 안보 위협 증가, 랜섬웨어 변종과 APT 공격의 진화, 디지털 신분증과 전자 문서 서비스로 인한 개인정보 탈취, 가상 자산을 노리는 다양한 사이버 공격, 그리고 제로데이와 엔데이 취약점을 악용한 공격의 증가가 예상됩니다.\n\n특히, 국가 간 갈등과 관련하여 국가 간 갈등이 심화됨에 따라 해킹 조직의 공격이 증가할 것으로 예측되며, 미사일 발사 및 방어 기술, 항공우주산업, 이동통신 등 다양한 분야에서 해킹 공격이 늘어날 것으로 전망되었습니다.\n\n랜섬웨어의 지속적인 유포와 APT 공격의 진화도 주목할 만한 부분으로 언급되었습니다. 디지털 신분증과 전자 문서 서비스 확대로 인한 공격, 가상 자산과 NFT 발생을 돕는 플랫폼의 증가로 인한 공격, 그리고 제로데이 취약점과 엔데이 취약점을 악용한 공격이 더욱 빈번해질 것으로 예상되며, 새로운 제로데이 취약점 발견 및 악용이 증가하고 있는 상황이라고 하였습니다.\n\n## 느낀점\n\n아무리 보안이 발전해도 새로운 취약점은 계속 발견되고 그에 맞춰 새로운 공격 기술이 나타나는걸 보고 정보보안은 끝이 없다는걸 느꼈다.\n\n새로운 취약점을 계속 발견하는 사람도 놀랍지만 그에 맞추어서 계속해서 보완하는 사람이 대단하다고 생각했다. 정보보안을 전공하는 사람들이 돈을 많이 받는 이유를 알 것 같았다.\n\n요즘 모바일 운전면허증, 모바일 신분증 등 다양한 정보가 디지털로 넘어가는 추세인데, 먼 미래에는 내 모든 정보를 디지털에서 보관할수도 있겠다는 생각을 했다. 동시에 보안 취약점 때문에 내 모든 정보가 유출될수도 있다고 생각하니 겁이 났다.\n\n## 3줄 요약\n\n- 국가 간 해킹이 증가할것으로 예상됨\n- 최근에 등장한 Zero-Day 공격 및 N-Day 공격이 증가함\n- 모바일 신분증 등 디지털 신분증을 노리는 공격이 증가할것으로 예상됨\n\n## 출처\n\nhttps://www.itworld.co.kr/news/268791#csidxe9630f0e82a0f7a84dc54b184d164c7\n","id":"a40d452b-3e2f-5759-8003-70cd806eb3ef","excerpt":"1. Log4j Log4j란? Java/Kotlin/Scala/Groovy/Clojure 코딩 도중에 프로그램의 로그를 기록해주는 라이브러리다. Log4j 보안 이슈 \n 와  를 이용한 공격이다. JNDP…","fields":{"slug":"/보안 최신 동향 copy/"},"frontmatter":{"date":"2023.08.17","title":"보안 최신 동향","description":"정보보안 이슈와 최신 정보 동향","tags":["정보보안"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#080808","images":{"fallback":{"src":"/static/6efa1c3d4032d8084670c8672af575d6/d7f1b/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg","srcSet":"/static/6efa1c3d4032d8084670c8672af575d6/40721/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg 162w,\n/static/6efa1c3d4032d8084670c8672af575d6/eec7d/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg 325w,\n/static/6efa1c3d4032d8084670c8672af575d6/d7f1b/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.jpg 649w","sizes":"(min-width: 649px) 649px, 100vw"},"sources":[{"srcSet":"/static/6efa1c3d4032d8084670c8672af575d6/984e9/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.webp 162w,\n/static/6efa1c3d4032d8084670c8672af575d6/070cc/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.webp 325w,\n/static/6efa1c3d4032d8084670c8672af575d6/02de4/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88.webp 649w","type":"image/webp","sizes":"(min-width: 649px) 649px, 100vw"}]},"width":649,"height":370}}}},"timeToRead":1},{"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n## 접근법\n\n### 첫번째 생각\n\n배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다.\n\n- 초록색, 빨강색 배양액의 개수는 총 10개라서 백트래킹을 사용해도 문제가 없을것이라고 생각했다.\n\n- 백트래킹을 한 뒤 BFS를 사용하여 최대 피울수 있는 꽃의 개수를 구하면 문제의 답을 구할수 있겠다고 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi0512/post/36c4b317-0700-4a2f-af1b-53ba5133cc57/image.png)\n\n내가 생각한 풀이가 맞았다.\n\n## 코드\n\n> 배양액의 경우의 수를 구하는 백트래킹\n\n```cpp\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\n```\n\n간단한 백트래킹으로 구현했다.\n\n> 피울수 있는 꽃의 개수를 구하는 BFS\n\n```cpp\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\n```\n\n피울수 있는 꽃의 개수를 리턴하였다.\n\n> 전체 코드\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint arr[51][51], n, m, maxi = -1, temp[51][51], dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\nbool inRange(int y, int x) {\n   if (y == n || y < 0 || x == m || x < 0) return false;\n   return true;\n}\nclass location {\npublic:\n   int x, y, col, dis;\n   location(int y, int x, int col, int dis) : y(y), x(x), col(col), dis(dis) {};\n};\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\nint main() {\n   int r, g;\n   cin >> n >> m >> g >> r;\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         cin >> arr[i][j];\n      }\n   }\n   queue <location> a;\n   bt(0, g, r);\n   cout << maxi;\n}\n```\n\n## 후기\n\n- 처음 생각한 로직이 맞아서 쉽게 풀 수 있는 문제였다.\n- **예전에 작성한 코드**라서 코드가 깔끔하지 못한점 이해 부탁드립니다.\n","id":"cdc1092b-279d-5139-8282-bfd46edf7f03","excerpt":"문제 문제 링크 접근법 첫번째 생각 배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다. 초록색, 빨강색 배양액의 개수는 총 1…","fields":{"slug":"/백준18809/"},"frontmatter":{"date":"2023.05.01","title":"[번역] 프런트엔드 풀 리퀘스트를 작성하기 전에 이 체크리스트를 사용하세요.","description":"백준 18809번","tags":["알고리즘","백준"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg","srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/c9087/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/a83f3/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 917w","sizes":"(min-width: 917px) 917px, 100vw"},"sources":[{"srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/2b505/%EC%B5%9C%EC%A0%81%ED%99%94.webp 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/564c1/%EC%B5%9C%EC%A0%81%ED%99%94.webp 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/f701a/%EC%B5%9C%EC%A0%81%ED%99%94.webp 917w","type":"image/webp","sizes":"(min-width: 917px) 917px, 100vw"}]},"width":917,"height":1200}}}},"timeToRead":3},{"rawMarkdownBody":"\n## 1. 아나콘다란?\n\n아나콘다는 머신러닝이나 데이터 분석 등에 사용하는 여러가지 패키지가 기본적으로 포함되어있는 파이썬 배포판입니다\n\n또한 파이썬 가상환경을 구축하는데 도움이 되는데, 내부적으로 `conda` 라는 환경 패키치 관리자가 존재해서 가상환경을 관리할수 있습니다.\n\n## 2. 아나콘다 가상환경이란?\n\n여러 개의 프로젝트 진행시 다른 프로젝트로 바꿀 때마다 다른 버전의 패키지를 설치해야 하는 문제가 생긴다.\n\n이러한 시간 낭비를 해결하기 위해서 가상 환경을 사용합니다.\n\n## 3. 가상환경 세팅법\n\n### 가상환경 만들기\n\n```python\nconda create -n \"가상환경이름\" python=\"원하는 파이썬 버전\"\n```\n\n### 가상환경 활성화\n\n```python\nconda activate \"가상환경이름\"\n```\n\n## 4. 주피터 노트북 가상환경 커널 연결법\n\n가상환경 생성: 아나콘다를 설치하고 나면 가상환경을 생성할 수 있습니다. 아래의 명령을 사용하여 가상환경을 생성할 수 있습니다. <가상환경이름>은 원하는 이름으로 바꿔주시면 됩니다.\n\n### 주피터 노트북 설치 및 커널 생성\n\n```python\nconda install jupyter\nipython kernel install --user --name=<커널이름>\n```\n\n### 주피터 노트북 실행\n\n```python\njupyter notebook\n```\n\n### 작업 완료 후 비활성화\n\n```python\nconda deactivate\n```\n\n## 5. 주피터 노트북 사용법\n\n### 아나콘다 설치 및 환경 설정\n\n[아나콘다 공식 웹사이트](https://www.anaconda.com/download)에서 아나콘다 배포판을 다운로드하고 설치합니다.\n설치 중에 환경 변수 설정을 선택하면, 시스템에 Anaconda 및 Miniconda 실행 파일의 경로가 추가되어 터미널에서 간편하게 실행할 수 있습니다.\n\n### 주피터 노트북 실행\n\n터미널 또는 Anaconda Prompt(Windows)를 열고 다음 명령으로 주피터 노트북을 실행합니다:\n\n```python\njupyter notebook\n```\n\n### 새 노트북 만들기\n\n주피터 노트북 대시보드에서 \"New\" 버튼을 클릭하고 \"Python 3\"을 선택하면 새 주피터 노트북이 생성됩니다.\n노트북의 제목을 클릭하여 원하는 이름으로 변경할 수 있습니다.\n\n### 코드 작성 및 실행\n\n주피터 노트북은 셀(Cell) 단위로 코드를 작성하고 실행할 수 있습니다. 셀은 코드를 입력하고 실행하는 단위입니다.\n새로운 셀을 생성하려면 \"+\" 버튼을 클릭하거나 키보드 단축키 B를 누릅니다.\n셀에 파이썬 코드를 입력하고 Shift + Enter를 눌러 실행합니다.\n결과나 출력 값이 나타납니다.\n\n### 셀 유형\n\n주피터 노트북은 코드 셀뿐만 아니라 마크다운(Markdown) 셀도 지원합니다.\n마크다운 셀은 문서 작성, 설명, 그림 추가 등에 사용됩니다.\n셀 유형을 변경하려면 셀 선택 후 상단의 드롭다운 메뉴에서 유형을 선택합니다.\n셀 실행 및 편집:\n\n셀 실행은 Shift + Enter를 사용하거나 상단 메뉴의 실행 버튼을 클릭합니다.\n셀 내용을 편집하려면 더블 클릭하거나 클릭 후 Enter 키를 누릅니다.\n\n### 노트북 저장 및 닫기\n\n노트북은 자동으로 주기적으로 저장되지만, 수동으로 저장하는 것이 좋습니다. 상단 메뉴의 저장 아이콘을 클릭하거나 Ctrl + S 키를 눌러 저장할 수 있습니다.\n노트북을 닫을 때에는 탭을 닫거나 \"File\" 메뉴에서 \"Close and Halt\"를 선택합니다.\n\n### 주피터 노트북 종료\n\n주피터 노트북 대시보드를 종료하려면 웹 브라우저 탭을 닫습니다. 주피터 노트북 대시보드 창이 열려있는 동안에는 해당 노트북 서버가 실행됩니다.\n","id":"59855106-7ce2-5d89-86fc-878ef216b435","excerpt":"…","fields":{"slug":"/파이썬 아나콘다/"},"frontmatter":{"date":"2023.08.21","title":"파이썬 아나콘다","description":"파이썬 아나콘다 가상환경과 주피터 노트북 사용법","tags":["opencv","python"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/0278039ce3bda73082339878beb60a46/a69cb/anaconda.png","srcSet":"/static/0278039ce3bda73082339878beb60a46/ee2c6/anaconda.png 264w,\n/static/0278039ce3bda73082339878beb60a46/62573/anaconda.png 528w,\n/static/0278039ce3bda73082339878beb60a46/a69cb/anaconda.png 1056w","sizes":"(min-width: 1056px) 1056px, 100vw"},"sources":[{"srcSet":"/static/0278039ce3bda73082339878beb60a46/2e2ac/anaconda.webp 264w,\n/static/0278039ce3bda73082339878beb60a46/a1f41/anaconda.webp 528w,\n/static/0278039ce3bda73082339878beb60a46/28bec/anaconda.webp 1056w","type":"image/webp","sizes":"(min-width: 1056px) 1056px, 100vw"}]},"width":1056,"height":560}}}},"timeToRead":1},{"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n# h1\n\n## h2\n\n### h3\n\n#### h4\n","id":"62d6137e-c9d3-5684-b52d-a358937f2c52","excerpt":"문제 문제 링크 h1 h2 h3 h4","fields":{"slug":"/면접 준비 copy/"},"frontmatter":{"date":"2023.05.03","title":"프론트엔드 면접 준비(Javascript)","description":"백준 18809번","tags":["알고리즘1","백준1"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg","srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/c9087/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/a83f3/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 917w","sizes":"(min-width: 917px) 917px, 100vw"},"sources":[{"srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/2b505/%EC%B5%9C%EC%A0%81%ED%99%94.webp 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/564c1/%EC%B5%9C%EC%A0%81%ED%99%94.webp 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/f701a/%EC%B5%9C%EC%A0%81%ED%99%94.webp 917w","type":"image/webp","sizes":"(min-width: 917px) 917px, 100vw"}]},"width":917,"height":1200}}}},"timeToRead":1},{"rawMarkdownBody":"\n## 문제\n\n[문제 링크](https://www.acmicpc.net/problem/18809)\n\n## 접근법\n\n### 첫번째 생각\n\n배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다.\n\n- 초록색, 빨강색 배양액의 개수는 총 10개라서 백트래킹을 사용해도 문제가 없을것이라고 생각했다.\n\n- 백트래킹을 한 뒤 BFS를 사용하여 최대 피울수 있는 꽃의 개수를 구하면 문제의 답을 구할수 있겠다고 생각했다.\n\n## 결과\n\n![](https://velog.velcdn.com/images/dohi0512/post/36c4b317-0700-4a2f-af1b-53ba5133cc57/image.png)\n\n내가 생각한 풀이가 맞았다.\n\n## 코드\n\n> 배양액의 경우의 수를 구하는 백트래킹\n\n```cpp\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\n```\n\n간단한 백트래킹으로 구현했다.\n\n> 피울수 있는 꽃의 개수를 구하는 BFS\n\n```cpp\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\n```\n\n피울수 있는 꽃의 개수를 리턴하였다.\n\n> 전체 코드\n\n```cpp\n#include <bits/stdc++.h>\nusing namespace std;\nint arr[51][51], n, m, maxi = -1, temp[51][51], dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\nbool inRange(int y, int x) {\n   if (y == n || y < 0 || x == m || x < 0) return false;\n   return true;\n}\nclass location {\npublic:\n   int x, y, col, dis;\n   location(int y, int x, int col, int dis) : y(y), x(x), col(col), dis(dis) {};\n};\nint bfs() {\n   queue <location> que;\n   int flower = 0;\n   int vis[51][51] = {};\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         temp[i][j] = arr[i][j];\n         if (temp[i][j] == 3 || temp[i][j] == 4) {\n            que.push(location(i, j, temp[i][j], 0));\n         }\n      }\n   }\n   while (!que.empty()) {\n      location data(que.front());\n      int x = data.x;\n      int y = data.y;\n      int col = data.col;\n      int dis = data.dis;\n      que.pop();\n      if (temp[y][x] == -1) continue;\n      for (int i = 0; i < 4; i++) {\n         int nx = x + dx[i];\n         int ny = y + dy[i];\n         if (inRange(ny, nx)) {\n            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {\n               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {\n                  temp[ny][nx] = -1;\n                  flower++;\n               }\n               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {\n                  temp[ny][nx] = col;\n                  vis[ny][nx] = dis + 1;\n                  que.push(location(ny, nx, col, dis + 1));\n               }\n            }\n         }\n      }\n   }\n   return flower;\n}\nvoid bt(int a, int g, int r) {\n   if (a == n * m + 1) return;\n   if (g == 0 && r == 0) {\n      int result = bfs();\n      maxi = max(result, maxi);\n      return;\n   }\n   int y = a / m;\n   int x = a % m;\n   if (arr[y][x] == 2 && g != 0) {\n      arr[y][x] = 3;\n      bt(a + 1, g - 1, r);\n      arr[y][x] = 2;\n   }\n   if (arr[y][x] == 2 && r != 0) {\n      arr[y][x] = 4;\n      bt(a + 1, g, r - 1);\n      arr[y][x] = 2;\n   }\n   bt(a + 1, g, r);\n\n}\nint main() {\n   int r, g;\n   cin >> n >> m >> g >> r;\n   for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n         cin >> arr[i][j];\n      }\n   }\n   queue <location> a;\n   bt(0, g, r);\n   cout << maxi;\n}\n```\n\n## 후기\n\n- 처음 생각한 로직이 맞아서 쉽게 풀 수 있는 문제였다.\n- **예전에 작성한 코드**라서 코드가 깔끔하지 못한점 이해 부탁드립니다.\n","id":"9e432420-c048-5042-a114-f4f8493e767e","excerpt":"문제 문제 링크 접근법 첫번째 생각 배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다. 초록색, 빨강색 배양액의 개수는 총 1…","fields":{"slug":"/백준18809 copy/"},"frontmatter":{"date":"2023.05.01","title":"[번역] 프런트엔드 풀 리퀘스트를 작성하기 전에 이 체크리스트를 사용하세요.","description":"백준 18809번","tags":["알고리즘2","백준2"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","backgroundColor":"#f8f8f8","images":{"fallback":{"src":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg","srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/c9087/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/a83f3/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/48bf9/%EC%B5%9C%EC%A0%81%ED%99%94.jpg 917w","sizes":"(min-width: 917px) 917px, 100vw"},"sources":[{"srcSet":"/static/3dc58a9ad7bd9414bb1813a91ec57bb8/2b505/%EC%B5%9C%EC%A0%81%ED%99%94.webp 229w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/564c1/%EC%B5%9C%EC%A0%81%ED%99%94.webp 459w,\n/static/3dc58a9ad7bd9414bb1813a91ec57bb8/f701a/%EC%B5%9C%EC%A0%81%ED%99%94.webp 917w","type":"image/webp","sizes":"(min-width: 917px) 917px, 100vw"}]},"width":917,"height":1200}}}},"timeToRead":3}]}}}