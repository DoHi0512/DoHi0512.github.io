---
title: "[번역] 프런트엔드 풀 리퀘스트를 작성하기 전에 이 체크리스트를 사용하세요."
date: "2023-05-01T22:12:03.284Z"
description: "백준 18809번"
tags: ["알고리즘", "백준"]
thumbnail: "./최적화.jpeg"
---

## 문제

[문제 링크](https://www.acmicpc.net/problem/18809)

## 접근법

### 첫번째 생각

배양액을 뿌릴 수 있는 경우의 수를 따져보기 위해 백트래킹을 사용해야겠다고 생각했다.

- 초록색, 빨강색 배양액의 개수는 총 10개라서 백트래킹을 사용해도 문제가 없을것이라고 생각했다.

- 백트래킹을 한 뒤 BFS를 사용하여 최대 피울수 있는 꽃의 개수를 구하면 문제의 답을 구할수 있겠다고 생각했다.

## 결과

![](https://velog.velcdn.com/images/dohi0512/post/36c4b317-0700-4a2f-af1b-53ba5133cc57/image.png)

내가 생각한 풀이가 맞았다.

## 코드

> 배양액의 경우의 수를 구하는 백트래킹

```cpp
void bt(int a, int g, int r) {
   if (a == n * m + 1) return;
   if (g == 0 && r == 0) {
      int result = bfs();
      maxi = max(result, maxi);
      return;
   }
   int y = a / m;
   int x = a % m;
   if (arr[y][x] == 2 && g != 0) {
      arr[y][x] = 3;
      bt(a + 1, g - 1, r);
      arr[y][x] = 2;
   }
   if (arr[y][x] == 2 && r != 0) {
      arr[y][x] = 4;
      bt(a + 1, g, r - 1);
      arr[y][x] = 2;
   }
   bt(a + 1, g, r);

}
```

간단한 백트래킹으로 구현했다.

> 피울수 있는 꽃의 개수를 구하는 BFS

```cpp
int bfs() {
   queue <location> que;
   int flower = 0;
   int vis[51][51] = {};
   for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
         temp[i][j] = arr[i][j];
         if (temp[i][j] == 3 || temp[i][j] == 4) {
            que.push(location(i, j, temp[i][j], 0));
         }
      }
   }
   while (!que.empty()) {
      location data(que.front());
      int x = data.x;
      int y = data.y;
      int col = data.col;
      int dis = data.dis;
      que.pop();
      if (temp[y][x] == -1) continue;
      for (int i = 0; i < 4; i++) {
         int nx = x + dx[i];
         int ny = y + dy[i];
         if (inRange(ny, nx)) {
            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {
               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {
                  temp[ny][nx] = -1;
                  flower++;
               }
               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {
                  temp[ny][nx] = col;
                  vis[ny][nx] = dis + 1;
                  que.push(location(ny, nx, col, dis + 1));
               }
            }
         }
      }
   }
   return flower;
}
```

피울수 있는 꽃의 개수를 리턴하였다.

> 전체 코드

```cpp
#include <bits/stdc++.h>
using namespace std;
int arr[51][51], n, m, maxi = -1, temp[51][51], dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };
bool inRange(int y, int x) {
   if (y == n || y < 0 || x == m || x < 0) return false;
   return true;
}
class location {
public:
   int x, y, col, dis;
   location(int y, int x, int col, int dis) : y(y), x(x), col(col), dis(dis) {};
};
int bfs() {
   queue <location> que;
   int flower = 0;
   int vis[51][51] = {};
   for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
         temp[i][j] = arr[i][j];
         if (temp[i][j] == 3 || temp[i][j] == 4) {
            que.push(location(i, j, temp[i][j], 0));
         }
      }
   }
   while (!que.empty()) {
      location data(que.front());
      int x = data.x;
      int y = data.y;
      int col = data.col;
      int dis = data.dis;
      que.pop();
      if (temp[y][x] == -1) continue;
      for (int i = 0; i < 4; i++) {
         int nx = x + dx[i];
         int ny = y + dy[i];
         if (inRange(ny, nx)) {
            if (temp[ny][nx] != 0 && temp[ny][nx] != -1) {
               if (temp[ny][nx] != col && vis[ny][nx] == dis + 1) {
                  temp[ny][nx] = -1;
                  flower++;
               }
               else if (temp[ny][nx] == 1 || temp[ny][nx] == 2) {
                  temp[ny][nx] = col;
                  vis[ny][nx] = dis + 1;
                  que.push(location(ny, nx, col, dis + 1));
               }
            }
         }
      }
   }
   return flower;
}
void bt(int a, int g, int r) {
   if (a == n * m + 1) return;
   if (g == 0 && r == 0) {
      int result = bfs();
      maxi = max(result, maxi);
      return;
   }
   int y = a / m;
   int x = a % m;
   if (arr[y][x] == 2 && g != 0) {
      arr[y][x] = 3;
      bt(a + 1, g - 1, r);
      arr[y][x] = 2;
   }
   if (arr[y][x] == 2 && r != 0) {
      arr[y][x] = 4;
      bt(a + 1, g, r - 1);
      arr[y][x] = 2;
   }
   bt(a + 1, g, r);

}
int main() {
   int r, g;
   cin >> n >> m >> g >> r;
   for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
         cin >> arr[i][j];
      }
   }
   queue <location> a;
   bt(0, g, r);
   cout << maxi;
}
```

## 후기

- 처음 생각한 로직이 맞아서 쉽게 풀 수 있는 문제였다.
- **예전에 작성한 코드**라서 코드가 깔끔하지 못한점 이해 부탁드립니다.
